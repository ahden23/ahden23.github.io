---
layout: post
title: "원근 투영 변환 (Perspective Projection Transformation)"
comments: true  
description: >
  에셋번들 의존성과 오버라이드 가능한 데이터 전파
date: 2024-04-30 22:30:05 +0900
category: rendering
tags: [rendering]
---

# 3D에서 2D 화면으로

원근 투영의 근본적인 목적을 기억하자:
우리 시야 안에 들어오는 3D 공간 상의 개체들을 2D 화면으로 맵핑시키는 것
그래서 z축은 사라지는 게 맞다. 그리고 일단 2D 화면으로 변환된 물체는 (z축이 사라졌기 때문에) 원래의 3D 공간으로 되돌아갈 수 없다.

# 뷰 공간에서 NDC 공간으로

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a713783-6cd5-464c-9e38-b0462a68df72/Untitled.png)

그러나 실제 원근 투영은 이렇다:
결론적으로 프러스텀 안의 모든 점들을 xyz축 요소 [-1, 1] 내의 큐브로 변환하는 것이 목표다. 이 큐브는 가로2 x 세로2 x 높이2 크기를 갖는다. (여기서 프러스텀은 시야각과 일정 z축 거리 (n, f)로 정의된다.)
그래서 축 기준으로 보면, 여전히 3D 공간에서 3D 공간으로의 변환이라고 볼 수 있다. 그러면 z축이 살아있는 이유는 무엇일까? 나중에 2D 화면 픽셀에 그리기 위한 래스터라이징 과정에서 z값에 따른 차폐 테스트 용도로 필요하기 때문이다. 

# 원근 투영 변환 구하기

## Step 1: 시점에서 투영 평면까지의 거리 구하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/273f353e-19e3-4b71-9faa-6a319f2980f4/Untitled.png)

1. 일단 단순하게 접근하기 위해서, 그림과 같이 X축은 없애고 YZ 평면만 고려하도록 하자. 이제 y와 z요소에만 신경쓰면 된다.
2. 또한 z 투영은 무시해보자. 그리고 근단면(near plane)과 원단면(far plane)도 우선 생각하지 말자. 앞서 언급한 것처럼, 원래 이론적으로 보자면 우리가 원하는 3D→2D로의 맵핑에서 z는 의미가 딱히 없다. 모든 점들이 일정한 상수 z값으로 맵핑되기 때문이다. 단지 z가 깊이 테스트 등을 이유로 나중에 쓸모가 있기 때문에 살려두어야 한다.
    1. 프러스텀은 너무 가깝거나 너무 멀어서 컬링을 위해 나중에 필요하다. 프러스텀에 포함되는 점들의 z는 [-1, 1] 사이로 맵핑해줘야 한다.
3. 이제는 뷰 공간의 시야각 안에 존재하는 점들을 (x:[-1, 1] y:[-1, 1] z:-d) 인 평면 영역에 투영하는 그림이 완성되었다.
4. **결론**
    1. **시야각만 알면, 투영 평면까지의 거리 d를 구할 수 있으며, 그 반대도 가능하다.**
    2. 이게 뭐지 싶을 수도 있지만, 중요한 건 단지 하나다. **거리 d값을 먼저 구한 이유는 다음 단계에 $Y_v$에서 $Y_{ndc}$*로의 변환식을*  구하기 위한 것이다.**

## Step 2: NDC Y 구하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c763f2f2-8e5a-4b2f-964b-f57830590ec6/Untitled.png)

- 일단 앞 단계에서 거리 d값을 구해서 알고 있는 상황이다.
- 시야 안의 임의의 점($Y_v$, $Z_v$)는 뷰 공간의 한 점으로 이미 설정해서 알고 있는 값이다.
- 이제 시야 안에 존재하는 점($Y_v$, $Z_v$)가 ($Y_{ndc}$, $-d$)에 맵핑되고, 그 관계는 닮은꼴 삼각형 관계이므로 이것을 활용하여 $Y_{ndc}$를 구할 수 있다.

## Step 3: NDC X 구하기

- 만약에 뷰 영역이 정사각형이라면 $Xndc$도 위에서 $Yndc$를 구한 식과 같은 것을 적용하면 되겠다. 그러나 현실은 그렇지 않고 보통 가로(횡)이 세로(종)보다 큰 종횡비를 가진다. 그래서 **x, y 요소 모두 동일하게 ndc 공간 [-1, 1] 영역에 맵핑하려면 종횡비를 적용해야 한다.** **(그러니까 결국 더 큰 쪽이 ndc에 빡빡하게 들어가겠지.)**
    
    $$
    종횡비\ \   a = w / h
    $$
    

## Step 4: 동차 원근 행렬 (1차 완성)

### NDC XY에 대한 해석

- 둘다 $Z_v$의 나눗셈이 들어간다.
- $Z_v$좌표로 나눗셈 연산이 들어간다는 말은 **행렬 연산으로 이 전체 변환을 표현할 수 없다는 것이다. (선형, 아핀 둘 다 아니기 때문에…)**

### 변환의 비선형적 요소를 해결할 구원투수: 동차좌표

- **동차 공간의 w요소를 활용하자.**
- 뷰 공간의 **w를 NDC 공간의 $-Z_v$로 맵핑하도록 변환식을 변형하자. 그러면 일단 나눗셈 요소는 사라질 것이다. 그리하여 이 새 변환을 적용하면, NDC 공간에서 w값이 $-Z_v$인 ndc 동차 좌표로 변환될 것이다.**
- **그 후 원본 좌표를 찾으려면 최종적으로 동차나누기를 사용하면 된다.**
- **적어도 동차 나누기 이전의 앞부분까지는 선형방정식으로 변환되어, 4차원 선형변환으로 우리가 쉽게 다룰 수 있게 되었다!**
- 결론
    - 원근 투영 변환은 동차 원근 행렬(4차원 선형 변환)과 동차 나누기라는 2단계로 구성된다.
    - 이 두 단계 중에 첫 단계를 거치면 클립 공간으로의 변환이 이루어지고, 그 다음에 클립 공간에서 NDC 공간으로의 변환이 일어난다.

## Step 5: 원래 없어도 될 NDC 공간의 $Z_{ndc}$ 일병 구하기

(원근 투영 변환에서 최종 나중에 w로 나누는 부분은 이 행렬과는 별개이므로 이야기와는 상관 없다.)

- 지금까지는 z 변환을 고려하지 않았다.
- 행렬의 가장 우측 열이 모두 0이므로 이 행렬은 역을 가지지 않는다.
    - 한 열이 모두 0이 된다는 건 차원 하나를 잃어버리기 때문이다. (나머지 기저벡터xyz는 맵핑되지만, 마지막 기저벡터는 (0, 0, 0, 0)이 된다.)
    - 다시 말해, 뷰 공간의 점들이 ndc 공간의 단일 z평면에 맵핑되기 때문에 생기는 당연한 결과다.
    - 즉,  ndc공간의 점을 다시 뷰 공간으로 놓는 건 불가능하다는 사실을 말해준다.
- **원래 투영은 3D 공간에서 2D 공간으로의 맵핑이기 때문에 차원을 잃어버리는 것은 이론적으로는 당연하다. 그러나 우리는 Z를 살려야 한다. 그래서 Zndc [-1, 1]로 맵핑해줘야 한다.**
    - **그 이유는 z가 깊이 테스트를 위해 필요한 필수 유용한 데이터이기 때문이다.**

## Step 6: 동차 원근 행렬 (2차 완성 - 최종)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ea290ba-db4b-40cd-90b3-f9dfc316a985/Untitled.png)

Z를 생각해보자. 우리는 [-n, -f]를 [-1, 1]로 맵핑해야 한다.

비례 축소인자 A와 이동인자 B를 구하여 ndc 공간 z 맵핑까지 포함한 최종 NDC 변환을 완성해보자:

- n과 f는 우리가 지정하는 값이므로 이미 알고 있는 값이다.
- 우리는 뷰 공간 near plane 위의 점 (0, 0, -n)가 ndc 공간 (0, 0, -1)로 맵핑되어야 하는 지를 이미 알고 있다. A와 B가 포함된 변환식에 대입하여 A와 B의 관계식을 만들자. 그래서 B를 A에 관한 식으로 치환해서 없애버리자.
- 우리는 뷰 공간 far plane 위의 점 (0, 0, -f)가 ndc 공간 (0, 0, 1)로 맵핑되어야 하는 지를 이미 알고 있다.
- 앞서, B를 제거하고 A만 포함한 변환식에 대입하여 최종 A를 구하자.

그러면 A를 통해 B도 구하게 되고, A와 B를 채운 최종 원근 행렬을 구할 수 있다.

### 다양한 z 맵핑

여기서는 [-n, -f] → [-1, 1] 맵핑이었으나, 그래픽스 API에 따라 z 맵핑이 다를 수 있다.

[n, f] → [-1, 1] 이럴 수도 있고,  [n, f] → [0, 1] 이럴 수도 있다. 이렇게 되면 당연히 변환 행렬은 우리가 앞서 구한 것과 다를 것이다.

### z의 정밀도

z의 정밀도를 유지하기 위해서는 근단면과 원단면이 서로 가깝도록 유지시키자.

### z의 비선형성?

가까울 수록 정밀도가 높고 뒤로 갈수록 낮게…


